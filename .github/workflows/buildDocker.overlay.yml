on:
  workflow_call:
    inputs:
      arch:
        type: string
        required: false
        default: linux/amd64
        description: Image arch to build and run
      buildContext:
        type: string
        required: false
        default: src
      buildArgs:
        type: string
        required: false
      imageFolder:
        type: string
        required: false
        description: Folder to save the build to
      imageFile:
        type: string
        required: false
        description: File basename of image to save the build to
      imageArtifact:
        type: string
        required: false
        description: Name of the image artifact to save the build to
      cacheTo:
        type: string
        required: false
        description: Cache key to save the build to
      cacheFrom:
        type: string
        required: false
        description: Cache key to load the build from
      cacheKey:
        type: string
        required: false
        description: Cache key to seperate unrelated caches
      imageName:
        type: string
        required: true
        description: Name of the image to build
      jobName:
        type: string
        required: false
        description: Name of the job to run
        default: ${{ github.workflow }}${{ inputs.id && inputs.id != 'default' && format(' ({0})', inputs.id)}}
      id:
        type: string
        required: false
        description: ID of the image
    outputs:
      inputs:
        value: ${{ jobs.build.outputs.inputs }}
      meta:
        value: ${{ jobs.build.outputs.meta }}
      imageFile:
        value: ${{ jobs.build.outputs.imageFile }}
      imageFolder:
        value: ${{ jobs.build.outputs.imageFolder }}
      imageArtifact:
        value: ${{ jobs.build.outputs.imageArtifact }}
      imagePath:
        value: ${{ jobs.build.outputs.imagePath }}
      cacheHint:
        value: ${{ jobs.build.outputs.cacheHint }}
jobs:
  build:
    name: ${{ inputs.jobName }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      inputs: ${{ steps.getInputs.outputs.value }}
      cacheHint: ${{ steps.getInputs.outputs.cacheHint }}
      meta: ${{ steps.buildImage.outputs.metadata }}
      imagePath: ${{ steps.getImagePath.outputs.value }}
      imageFile: ${{ steps.getInputs.outputs.imageFile }}
      imageFolder: ${{ steps.getInputs.outputs.imageFolder }}
      imageArtifact: ${{ steps.getInputs.outputs.imageArtifact }}
    steps:
      - name: checkout
        uses: actions/checkout@v3.5.3
      - name: setupNode
        uses: actions/setup-node@v3.7.0
        with:
          node-version: latest
      - name: installNodePackages
        shell: bash
        run: |
          cd
          npm install --no-save --no-package-lock @actions/core read-file-string execa vm2 fs-extra prevent-end
      - id: getInputs
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
          github: ${{ toJSON(github) }}
        run: |
          import core from '@actions/core'
          import preventEnd from 'prevent-end'
          const inputs = JSON.parse(process.env.inputs)
          const github = JSON.parse(process.env.github)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const outputs = {
            ...inputs
          }
          if (!outputs.id) {
            outputs.id = 'default'
          }
          if (!outputs.cacheKey) {
            outputs.cacheKey = `${github.repository}|${github.workflow}|${github.ref_name}|${outputs.id}`
          }
          if (!outputs.cacheFrom) {
            outputs.cacheFrom = `type=gha,scope=${outputs.cacheKey}`
          }
          if (!outputs.cacheTo) {
            outputs.cacheTo = `type=gha,scope=${outputs.cacheKey},mode=max`
          }
          output.cacheHint = preventEnd(outputs.cacheTo, ',mode=max')
          if (!outputs.imageFile) {
            outputs.imageFile = `${outputs.imageName}.tar`
          }
          if (!outputs.imageArtifact) {
            outputs.imageArtifact = `${github.run_id}_${outputs.id}`
          }
          if (!outputs.imageFolder) {
            outputs.imageFolder = `/tmp/dockerBuild/${github.run_id}_${outputs.id}`
          }
          for (const [key, value] of Object.entries(outputs)) {
            setOutput(value, key)
          }
          setOutput(JSON.stringify(outputs))
      - name: setupQemu
        if: ${{ inputs.arch != 'linux/amd64' }}
        uses: docker/setup-qemu-action@v2.2.0
        with:
          platforms: ${{ inputs.arch }}
      - name: setupBuildx
        uses: docker/setup-buildx-action@v2.8.0
      - name: ensureImageFolder
        shell: bash
        env:
          imageFolder: ${{ steps.getInputs.outputs.imageFolder }}
        run: mkdir --parents "$imageFolder"
      - id: getImagePath
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ steps.getInputs.outputs.value }}
        run: |
          import core from '@actions/core'
          import path from 'path'
          const inputs = JSON.parse(process.env.inputs)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const imagePath = path.resolve(inputs.imageFolder, inputs.imageFile)
          setOutput(imagePath)
      - name: buildImage
        id: buildImage
        uses: docker/build-push-action@v4.1.1
        with:
          context: ${{ inputs.buildContext }}
          platforms: ${{ inputs.arch }}
          build-args: ${{ inputs.buildArgs }}
          outputs: type=docker,dest=${{ steps.getImagePath.outputs.value }}
          cache-to: ${{ steps.getInputs.outputs.cacheTo }}
          cache-from: ${{ steps.getInputs.outputs.cacheFrom }}
          tags: ${{ inputs.imageName }}:.build
      - name: saveArtifact
        if: ${{ steps.getInputs.outputs.imageArtifact }}
        uses: actions/upload-artifact@v3.1.2
        with:
          name: ${{ steps.getInputs.outputs.imageArtifact }}
          path: ${{ steps.getInputs.outputs.imageFolder }}
      - id: checkArtifact
        shell: bash
        env:
          imageFolder: ${{ steps.getInputs.outputs.imageFolder }}
        run: |
          ls -l --almost-all --block-size 1 --color=always "$imageFolder"