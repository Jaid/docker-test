name: pushDocker
on:
  workflow_call:
    inputs:
      arch:
        type: string
        required: false
        default: ''
        description: List of image archs to build, comma separated without spaces
      buildContext:
        type: string
        required: false
        default: src
      dockerHubUser:
        type: string
        required: false
        default: ''
        description: If unset, the Docker Hub user will be the same as the GitHub user
      dockerHubRegistry:
        type: string
        required: false
        default: docker.io
      githubRegistry:
        type: string
        required: false
        default: ghcr.io
      baseTags:
        type: string
        required: false
        default: type=ref,event=branch
      addShaTags:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the commit’s SHA hash (good for persistence and debugging, but might produce a lot of clutter)
      addScheduleTags:
        type: boolean
        required: false
        default: false
        description: If true, create Docker image tags named after the current date (good for persistence and debugging, but might produce a lot of clutter) (only on schedule events)
      addVersionTag:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the new current version (only on push tag events)
      versionTagPrefix:
        type: string
        required: false
        default: ''
        description: Will be appended to the automatically generated version tag (only if addVersionTag is true and event is push tag)
      additionalTags:
        type: string
        required: false
        default: null
      versionTag:
        type: string
        required: false
        default: null
      versionTagSemverPrefix:
        type: string
        required: false
        default: null
        description: If given, this will be the semver’s prefix
      flavorLatest:
        type: string
        required: false
        default: auto
      flavorPrefix:
        type: string
        required: false
        default: ''
      flavorSuffix:
        type: string
        required: false
        default: ''
      flavorConnectionString:
        type: string
        required: false
        default: '-'
      readmePath:
        type: string
        required: false
        default: readme.md
      buildArgs:
        type: string
        required: false
        default: ''
      ### testDocker
      testEval:
        type: string
        required: false
        default: status === 0
      testDockerRunArgs:
        type: string
        required: false
      testAppArgs:
        type: string
        required: false
      ### makeDockerTagMatrix
      matrixBases:
        description: List of base images, split by anything
        required: false
        type: string
      matrixPlatform:
        description: List of platforms, split by anything
        required: false
        type: string
      matrixAdditionEvals:
        description: List of additional values, javascript object code without outer braces
        required: false
        type: string
      matrixFlavorEval:
        description: Javascript code to generate the id
        required: false
        type: string
    secrets:
      dockerHubToken:
        required: false
        description: 'Create here with “Read, Write”: https://hub.docker.com/settings/security?generateToken=true'
    outputs:
      meta:
        value: ${{ jobs.push.outputs.meta }}
      digest:
        value: ${{ jobs.push.outputs.digest }}
      imageId:
        value: ${{ jobs.push.outputs.imageId }}
      imageName:
        value: ${{ jobs.push.outputs.imageName }}
      imageSlug:
        value: ${{ jobs.push.outputs.imageSlug }}
      imageUser:
        value: ${{ jobs.push.outputs.imageUser }}
jobs:
  getDockerImageName:
    name: getDockerImageName
    uses: jaid/workflows/.github/workflows/getDockerImageName.yml@main
    with:
      dockerHubUser: ${{ inputs.dockerHubUser }}
  makeMatrix:
    name: makeMatrix
    uses: ./.github/workflows/.makeDockerTagMatrix.yml
    with:
      bases: ${{ inputs.matrixBases }}
      platform: ${{ inputs.matrixPlatform }}
      additionEvals: ${{ inputs.matrixAdditionEvals }}
      flavorEval: ${{ inputs.matrixFlavorEval }}
  build:
    name: build${{ matrix.id && format(' ({0})', matrix.id) }}
    needs:
      - makeMatrix
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.makeMatrix.outputs.output) }}
    uses: ./.github/workflows/.buildDocker.yml
    with:
      arch: ${{ matrix.platform }}
      buildContext: ${{ inputs.buildContext }}
      buildArgs: ${{ inputs.buildArgs }}
      id: ${{ matrix.id }}
  test:
    name: test${{ matrix.id && format(' ({0})', matrix.id) }}
    needs:
      - makeMatrix
      - build
    strategy:
      matrix:
        include: ${{ fromJson(needs.makeMatrix.outputs.nativeArch) }}
    uses: ./.github/workflows/.testDocker.yml
    with:
      dockerRunArgs: ${{ inputs.testDockerRunArgs }}
      appArgs: ${{ inputs.testAppArgs }}
      testEval: ${{ inputs.testEval }}
      id: ${{ matrix.id }}
  # push:
  #   needs:
  #     - getDockerImageName
  #     - makeMatrix
  #     - test
  #   name: push${{ matrix.id && format(' ({0})', matrix.id) }}
  #   runs-on: ubuntu-latest
  #   permissions:
  #     packages: write
  #     contents: read
  #   strategy:
  #     matrix:
  #       include: ${{ fromJson(needs.makeMatrix.outputs.output) }}
  #   outputs:
  #     meta: ${{ steps.dockerPush.outputs.metadata }}
  #     digest: ${{ steps.dockerPush.outputs.digest }}
  #     imageId: ${{ steps.dockerPush.outputs.imageid }}
  #     imageSlug: ${{ needs.getDockerImageName.outputs.imageSlug }}
  #     imageUser: ${{ needs.getDockerImageName.outputs.imageUser }}
  #     imageName: ${{ needs.getDockerImageName.outputs.imageName }}
  #   steps:
  #     - name: checkout
  #       uses: actions/checkout@v3.5.3
  #     - name: setupNode
  #       uses: actions/setup-node@v3.7.0
  #       with:
  #         node-version: latest
  #         cache: npm
  #         cache-dependency-path: ../package-lock.json
  #     - name: installNodePackages
  #       shell: bash
  #       run: |
  #         cd ..
  #         npm install @actions/core @actions/github read-file-string
  #     - name: getDockerHubTokenLength
  #       id: getDockerHubTokenLength
  #       shell: sh -c "node --input-type module < {0}"
  #       env:
  #         secrets: ${{ toJSON(secrets) }}
  #       run: |
  #         import core from '@actions/core'
  #         const secrets = JSON.parse(process.env.secrets)
  #         core.setOutput('length', secrets.dockerHubToken?.length ?? 0)
  #     - name: getCacheInstruction
  #       id: getCacheInstruction
  #       shell: sh -c "node --input-type module < {0}"
  #       env:
  #         needs: ${{ toJSON(needs) }}
  #         steps: ${{ toJSON(steps) }}
  #       run: |
  #         import core from '@actions/core'
  #         const needs = JSON.parse(process.env.needs)
  #         const steps = JSON.parse(process.env.steps)
  #         const setCacheInstruction = cacheInstruction => {
  #           core.setOutput('cache-from', cacheInstruction)
  #           core.setOutput('cache-to', `${cacheInstruction},mode=max`)
  #         }
  #         if (steps.getDockerHubTokenLength.outputs.length > 0) {
  #           setCacheInstruction(`type=registry,ref=${needs.getDockerImageName.outputs.imageSlug}:buildcache`)
  #         } else {
  #           setCacheInstruction('type=gha')
  #         }
  #     - name: getImageRefs
  #       id: getImageRefs
  #       shell: sh -c "node --input-type module < {0}"
  #       env:
  #         inputs: ${{ toJSON(inputs) }}
  #         dockerHubRef: ${{ needs.getDockerImageName.outputs.imageSlug }}
  #         getDockerHubTokenLength: ${{ steps.getDockerHubTokenLength.outputs.length }}
  #       run: |
  #         import core from '@actions/core'
  #         import { context } from '@actions/github'
  #         const inputs = JSON.parse(process.env.inputs)
  #         const refs = []
  #         const githubRef = `${inputs.githubRegistry}/${context.payload.repository.full_name.toLowerCase()}`
  #         console.dir({githubRef})
  #         core.setOutput('githubRef', githubRef)
  #         refs.push(githubRef)
  #         if (process.env.getDockerHubTokenLength > 0) {
  #           const dockerHubRef = `${inputs.dockerHubRegistry}/${process.env.dockerHubRef}`
  #           console.dir({dockerHubRef})
  #           core.setOutput('dockerHubRef', dockerHubRef)
  #           refs.push(dockerHubRef)
  #         }
  #         const output = refs.join('\n')
  #         console.dir({output})
  #         core.setOutput('value', output)
  #     - name: getArch
  #       id: getArch
  #       shell: sh -c "node --input-type module < {0}"
  #       env:
  #         inputs: ${{ toJSON(inputs) }}
  #       run: |
  #         import core from '@actions/core'
  #         import readFileString from 'read-file-string'
  #         const inputs = JSON.parse(process.env.inputs)
  #         const getArch = async () => {
  #           if (inputs.arch) {
  #             return inputs.arch.split(',')
  #           } else {
  #             const archLines = await readFileString.default('arch.lines')
  #             if (archLines) {
  #               return archLines.split('\n').map(line => line.trim()).filter(Boolean)
  #             } else {
  #               return ['linux/amd64']
  #             }
  #           }
  #         }
  #         const archs = await getArch()
  #         core.setOutput('arch', archs.join('\n'))
  #     - name: prepareVersionTag
  #       id: prepareVersionTag
  #       shell: sh -c "node --input-type module < {0}"
  #       env:
  #         inputs: ${{ toJson(inputs) }}
  #       run: |
  #         import core from '@actions/core'
  #         const inputs = JSON.parse(process.env.inputs)
  #         const getCleanedVersionTag = tag => {
  #           if (!tag) {
  #             return ''
  #           }
  #           if (inputs.versionTagSemverPrefix == null) {
  #             return tag
  #           }
  #           const semver = /(?<versionPrefix>v?)(?<version>\d+\.\d+\.\d+)/.exec(tag)?.groups
  #           if (semver) {
  #             return `${inputs.versionTagSemverPrefix}${semver.version}`
  #           }
  #           return tag
  #         }
  #         core.setOutput('versionTag', getCleanedVersionTag(inputs.versionTag))
  #     - name: getTags
  #       id: getTags
  #       shell: sh -c "node --input-type module < {0}"
  #       env:
  #         inputs: ${{ toJSON(inputs) }}
  #         steps: ${{ toJSON(steps) }}
  #       run: |
  #         import core from '@actions/core'
  #         const inputs = JSON.parse(process.env.inputs)
  #         const steps = JSON.parse(process.env.steps)
  #         const tags = []
  #         const add = input => {
  #           if (!input) {
  #             return
  #           }
  #           let addition
  #           if (typeof input === 'string') {
  #             addition = input.split('\n')
  #           } else {
  #             addition = input
  #           }
  #           for (const tag of addition) {
  #             if (tag) {
  #               console.dir(tag)
  #               tags.push(tag.trim())
  #             }
  #           }
  #         }
  #         add(inputs.baseTags)
  #         add(inputs.additionalTags)
  #         if (steps.prepareVersionTag.outputs.versionTag) {
  #           add(`type=raw,value=${steps.prepareVersionTag.outputs.versionTag}`)
  #         }
  #         if (inputs.addVersionTag) {
  #           add(`type=pep440,pattern=${inputs.versionTagPrefix ?? ''}{{version}}`)
  #         }
  #         if (inputs.addShaTags) {
  #           add('type=sha,format=long')
  #         }
  #         if (inputs.addScheduleTags) {
  #           add('type=schedule,pattern=nightly')
  #           add('type=schedule,pattern={{date \'YYYYMMDD\'}}')
  #         }
  #         if (!tags.length) {
  #           core.error('No tags given')
  #           process.exit(1)
  #         }
  #         core.setOutput('tags', tags.join('\n'))
  #     - name: setupQemu
  #       if: ${{ steps.getArch.outputs.arch != 'linux/amd64' }}
  #       uses: docker/setup-qemu-action@v2.2.0
  #       with:
  #         platforms: ${{ steps.getArch.outputs.arch }}
  #     - name: setupBuildx
  #       uses: docker/setup-buildx-action@v2.8.0
  #     - name: login (${{ needs.getDockerImageName.outputs.imageUser }} @ ${{ inputs.dockerHubRegistry }})
  #       if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 }}
  #       uses: docker/login-action@v2.2.0
  #       with:
  #         username: ${{ needs.getDockerImageName.outputs.imageUser }}
  #         password: ${{ secrets.dockerHubToken }}
  #     - name: login (${{ github.actor }} @ ${{ inputs.githubRegistry }})
  #       uses: docker/login-action@v2.2.0
  #       with:
  #         registry: ${{ inputs.githubRegistry }}
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}
  #     - name: extractDockerMetadata
  #       id: meta
  #       uses: docker/metadata-action@v4.6.0
  #       with:
  #         images: ${{ steps.getImageRefs.outputs.imageRefs }}
  #         labels: |
  #           maintainer=${{ github.actor }}
  #           org.opencontainers.image.vendor=${{ github.actor }}
  #           org.opencontainers.image.title=${{ needs.getDockerImageName.outputs.imageName }}
  #         tags: ${{ steps.getTags.outputs.tags }}
  #         flavor: |
  #           latest=${{ inputs.flavorLatest }}
  #           prefix=${{ inputs.flavorPrefix && format('{0}{1}', inputs.flavorPrefix, inputs.flavorConnectionString) || '' }}
  #           suffix=${{ inputs.flavorSuffix && format('{0}{1}', inputs.flavorConnectionString, inputs.flavorSuffix) || '' }}
  #     - name: downloadTestImage
  #       uses: actions/download-artifact@v3.0.2
  #       with:
  #         name: ${{ needs.test.outputs.imageArtifact }}
  #         path: ${{ needs.test.outputs.imageFolder }}
  #     - name: loadTestImage
  #       run: |
  #         docker load --input ${{ needs.test.outputs.imagePath }}
  #     - id: debug
  #       run: docker image ls
  #     - name: dockerPush
  #       id: dockerPush
  #       uses: docker/build-push-action@v4.1.1
  #       with:
  #         context: ${{ inputs.buildContext }}
  #         platforms: ${{ matrix.platform }}
  #         tags: ${{ steps.meta.outputs.tags }}
  #         labels: ${{ steps.meta.outputs.labels }}
  #         cache-to: ${{ needs.test.outputs.cacheTo }}
  #         cache-from: type=registry,ref=${{ steps.getDockerImageName.outputs.imageSlug }}
  #         push: true
  #     - name: dockerSyncReadme
  #       if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && inputs.readmePath }}
  #       uses: peter-evans/dockerhub-description@v3.4.1
  #       with:
  #         username: ${{ needs.getDockerImageName.outputs.imageUser }}
  #         password: ${{ secrets.dockerHubToken }}
  #         readme-filepath: ${{ inputs.readmePath }}
  #         repository: ${{ needs.getDockerImageName.outputs.imageSlug }}