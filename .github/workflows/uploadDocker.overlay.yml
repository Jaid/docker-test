on:
  workflow_call:
    inputs:
      arch:
        type: string
        required: false
        default: linux/amd64
        description: Image arch to build and push
      dockerHubUser:
        type: string
        required: false
        default: ''
        description: If unset, the Docker Hub user will be the same as the GitHub user
      dockerHubRegistry:
        type: string
        required: false
        default: docker.io
      githubRegistry:
        type: string
        required: false
        default: ghcr.io
      baseTags:
        type: string
        required: false
        default: type=ref,event=branch
      addShaTags:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the commit’s SHA hash (good for persistence and debugging, but might produce a lot of clutter)
      addScheduleTags:
        type: boolean
        required: false
        default: false
        description: If true, create Docker image tags named after the current date (good for persistence and debugging, but might produce a lot of clutter) (only on schedule events)
      addVersionTag:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the new current version (only on push tag events)
      versionTagPrefix:
        type: string
        required: false
        default: ''
        description: Will be appended to the automatically generated version tag (only if addVersionTag is true and event is push tag)
      additionalTags:
        type: string
        required: false
        default: null
      versionTag:
        type: string
        required: false
        default: null
      versionTagSemverPrefix:
        type: string
        required: false
        default: null
        description: If given, this will be the semver’s prefix
      flavorLatest:
        type: string
        required: false
        default: auto
      flavorPrefix:
        type: string
        required: false
        default: ''
      flavorSuffix:
        type: string
        required: false
        default: ''
      flavorConnectionString:
        type: string
        required: false
        default: '-'
      nameSuffix:
        type: string
        required: false
        description: Suffix to append to the job name
      imageSlug:
        type: string
        required: false
        description: Slug of the image
      id:
        type: string
        required: false
        description: ID of the image
      buildOutput:
        type: string
        required: true
        description: Output of the build job in JSON
      title:
        type: string
        required: false
        description: Title of the image
    secrets:
      dockerHubToken:
        required: false
        description: 'Create here with “Read, Write”: https://hub.docker.com/settings/security?generateToken=true'
jobs:
  upload:
    name: upload${{ inputs.nameSuffix }}
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: checkout
        uses: actions/checkout@v3.5.3
      - name: setupNode
        uses: actions/setup-node@v3.7.0
        with:
          node-version: latest
      - name: installNodePackages
        shell: bash
        run: npm install --no-save --no-package-lock @actions/core @actions/github read-file-string lodash-es sort-keys
      - id: getInputs
        name: getInputs
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
        run: |
          import core from '@actions/core'
          import sortKeys from 'sort-keys'
          import {camelCase, omit} from 'lodash-es'
          const inputs = JSON.parse(process.env.inputs)
          const buildOutput = JSON.parse(inputs.buildOutput)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const outputs = {
            ...omit(inputs, ['buildOutput']),
          }
          for (const [key, value] of Object.entries(buildOutput)) {
            const exclusiveKey = camelCase(`build ${key}`)
            outputs[exclusiveKey] = value
          }
          if (!outputs.id) {
            outputs.id = 'default'
          }
          if (!outputs.title) {
            if (outputs.id === 'default') {
              outputs.title = buildOutput.imageName
            } else {
              outputs.title = `${buildOutput.imageName} (${outputs.id})`
            }
          }
          for (const [key, value] of Object.entries(sortKeys(outputs))) {
            setOutput(value, key)
          }
          setOutput(JSON.stringify(outputs))
      - name: getDockerHubTokenLength
        id: getDockerHubTokenLength
        shell: sh -c "node --input-type module < {0}"
        env:
          secrets: ${{ toJSON(secrets) }}
        run: |
          import core from '@actions/core'
          const secrets = JSON.parse(process.env.secrets)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          setOutput(secrets.dockerHubToken?.length ?? 0)
      - name: getGithubPackagesRef
        id: getGithubPackagesRef
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ steps.getInputs.outputs.value }}
        run: |
          import core from '@actions/core'
          import { context } from '@actions/github'
          const inputs = JSON.parse(process.env.inputs)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const githubRef = `${inputs.githubRegistry}/${context.payload.repository.full_name.toLowerCase()}/${inputs.buildImageName}`
          setOutput(githubRef)
      - name: getDockerHubRef
        id: getDockerHubRef
        if: ${{ steps.getDockerHubTokenLength.outputs.value > 0 }}
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ steps.getInputs.outputs.value }}
          dockerHubTokenLength: ${{ steps.getDockerHubTokenLength.outputs.value }}
        run: |
          import core from '@actions/core'
          const inputs = JSON.parse(process.env.inputs)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          if (process.env.dockerHubTokenLength > 0) {
            const dockerHubRef = `${inputs.dockerHubRegistry}/${inputs.imageSlug}`
            setOutput(dockerHubRef)
          }
      - name: getRefs
        id: getRefs
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ steps.getInputs.outputs.value }}
          githubRef: ${{ steps.getGithubPackagesRef.outputs.value }}
          dockerHubRef: ${{ steps.getDockerHubRef.outputs.value }}
        run: |
          import core from '@actions/core'
          import { context } from '@actions/github'
          const inputs = JSON.parse(process.env.inputs)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const refs = [process.env.githubRef]
          if (process.env.dockerHubRef) {
            refs.push(process.env.dockerHubRef)
          }
          const output = refs.join('\n')
          setOutput(output)
      - name: prepareVersionTag
        id: prepareVersionTag
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ steps.getInputs.outputs.value }}
        run: |
          import core from '@actions/core'
          const inputs = JSON.parse(process.env.inputs)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const getCleanedVersionTag = tag => {
            if (!tag) {
              return ''
            }
            if (inputs.versionTagSemverPrefix == null) {
              return tag
            }
            const semver = /(?<versionPrefix>v?)(?<version>\d+\.\d+\.\d+)/.exec(tag)?.groups
            if (semver) {
              return `${inputs.versionTagSemverPrefix}${semver.version}`
            }
            return tag
          }
          setOutput(getCleanedVersionTag(inputs.versionTag))
      - name: getTags
        id: getTags
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ steps.getInputs.outputs.value }}
          versionTag: ${{ steps.prepareVersionTag.outputs.value }}
        run: |
          import core from '@actions/core'
          const inputs = JSON.parse(process.env.inputs)
          const setOutput = (value, name = 'value') => {
            core.setOutput(name, value)
            core.info(`Output ${name}: ${value}`)
          }
          const tags = []
          const add = input => {
            if (!input) {
              return
            }
            let addition
            if (typeof input === 'string') {
              addition = input.split('\n')
            } else {
              addition = input
            }
            for (const tag of addition) {
              if (tag) {
                tags.push(tag.trim())
              }
            }
          }
          add(inputs.baseTags)
          add(inputs.additionalTags)
          if (process.env.versionTag) {
            add(`type=raw,value=${process.env.versionTag}`)
          }
          if (inputs.addVersionTag) {
            add(`type=pep440,pattern=${inputs.versionTagPrefix ?? ''}{{version}}`)
          }
          if (inputs.addShaTags) {
            add('type=sha,format=long')
          }
          if (inputs.addScheduleTags) {
            add('type=schedule,pattern=nightly')
            add('type=schedule,pattern={{date \'YYYYMMDD\'}}')
          }
          if (!tags.length) {
            core.error('No tags given')
            process.exit(1)
          }
          setOutput(tags.join('\n'))
      - name: login (${{ steps.getInputs.outputs.dockerHubUser }} @ ${{ steps.getInputs.outputs.dockerHubRegistry }})
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 }}
        uses: docker/login-action@v2.1.0
        with:
          username: ${{ steps.getInputs.outputs.dockerHubUser }}
          password: ${{ secrets.dockerHubToken }}
      - name: login (${{ github.actor }} @ ${{ steps.getInputs.outputs.githubRegistry }})
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ steps.getInputs.outputs.githubRegistry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: extractDockerMetadata
        id: extractDockerMetadata
        uses: docker/metadata-action@v4.6.0
        with:
          images: ${{ steps.getRefs.outputs.value }}
          labels: |
            maintainer=${{ github.actor }}
            org.opencontainers.image.vendor=${{ github.actor }}
            org.opencontainers.image.title=${{ steps.getInputs.outputs.title }}
          tags: ${{ steps.getTags.outputs.tags }}
          flavor: |
            latest=${{ steps.getInputs.outputs.flavorLatest }}
            prefix=${{ steps.getInputs.outputs.flavorPrefix && format('{0}{1}', steps.getInputs.outputs.flavorPrefix, steps.getInputs.outputs.flavorConnectionString) || '' }}
            suffix=${{ steps.getInputs.outputs.flavorSuffix && format('{0}{1}', steps.getInputs.outputs.flavorConnectionString, steps.getInputs.outputs.flavorSuffix) || '' }}
      - name: setupQemu
        if: ${{ steps.getInputs.outputs.arch != 'linux/amd64' }}
        uses: docker/setup-qemu-action@v2.2.0
        with:
          platforms: ${{ steps.getInputs.outputs.arch }}
      - name: setupBuildx
        uses: docker/setup-buildx-action@v2.9.1
        with:
          platforms: ${{ steps.getInputs.outputs.arch }}
      - name: dockerPush
        id: dockerPush
        uses: docker/build-push-action@v4.1.1
        with:
          push: true
          platforms: ${{ steps.getInputs.outputs.arch }}
          tags: ${{ steps.extractDockerMetadata.outputs.tags }}
          labels: ${{ steps.extractDockerMetadata.outputs.labels }}
          cache-from: ${{ fromJson(steps.getInputs.outputs.buildInputs).cacheHint }}
          context: ${{ steps.getInputs.outputs.buildContext }}
          build-args: ${{ steps.getInputs.outputs.buildBuildArgs }}